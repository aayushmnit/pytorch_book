<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.2.226">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>The PyTorch Book - 3&nbsp; Broadcasting</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../basics/3_autograd.html" rel="next">
<link href="../basics/1_pytorch_tensors.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-Q8J05XS7Q7"></script>

<script type="text/javascript">

window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-Q8J05XS7Q7', { 'anonymize_ip': true});
</script>


</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Broadcasting</span></h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">The PyTorch Book</a> 
        <div class="sidebar-tools-main">
    <a href="" title="Share" id="sidebar-tool-dropdown-0" class="sidebar-tool dropdown-toggle px-1" data-bs-toggle="dropdown" aria-expanded="false"><i class="bi bi-share"></i></a>
    <ul class="dropdown-menu" aria-labelledby="sidebar-tool-dropdown-0">
        <li>
          <a class="dropdown-item sidebar-tools-main-item" href="https://www.linkedin.com/sharing/share-offsite/?url=|url|">
            <i class="bi bi-bi-linkedin pe-1"></i>
          LinkedIn
          </a>
        </li>
        <li>
          <a class="dropdown-item sidebar-tools-main-item" href="https://twitter.com/intent/tweet?url=|url|">
            <i class="bi bi-bi-twitter pe-1"></i>
          Twitter
          </a>
        </li>
        <li>
          <a class="dropdown-item sidebar-tools-main-item" href="https://www.facebook.com/sharer/sharer.php?u=|url|">
            <i class="bi bi-bi-facebook pe-1"></i>
          Facebook
          </a>
        </li>
    </ul>
  <a href="" class="quarto-color-scheme-toggle sidebar-tool" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
      <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
      </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">Preface</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">PyTorch basics</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../basics/0_pytorch_intro.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">PyTorch Introduction and Installation</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../basics/1_pytorch_tensors.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Tensors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../basics/2_broadcasting.html" class="sidebar-item-text sidebar-link active"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Broadcasting</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../basics/3_autograd.html" class="sidebar-item-text sidebar-link"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Automatic Differentiation</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#what-is-broadcasting" id="toc-what-is-broadcasting" class="nav-link active" data-scroll-target="#what-is-broadcasting"><span class="toc-section-number">3.1</span>  What is Broadcasting?</a></li>
  <li><a href="#exercise-k-means-using-broadcasting-principle" id="toc-exercise-k-means-using-broadcasting-principle" class="nav-link" data-scroll-target="#exercise-k-means-using-broadcasting-principle"><span class="toc-section-number">3.2</span>  Exercise: K Means using Broadcasting principle</a>
  <ul class="collapse">
  <li><a href="#create-some-random-data" id="toc-create-some-random-data" class="nav-link" data-scroll-target="#create-some-random-data"><span class="toc-section-number">3.2.1</span>  Create some random data</a></li>
  <li><a href="#randomly-initialize-the-centroids" id="toc-randomly-initialize-the-centroids" class="nav-link" data-scroll-target="#randomly-initialize-the-centroids"><span class="toc-section-number">3.2.2</span>  Randomly initialize the centroids</a></li>
  <li><a href="#assign-cluster-to-the-nearest-centroid" id="toc-assign-cluster-to-the-nearest-centroid" class="nav-link" data-scroll-target="#assign-cluster-to-the-nearest-centroid"><span class="toc-section-number">3.2.3</span>  Assign cluster to the nearest centroid</a></li>
  <li><a href="#update-centroids-based-on-new-clusters" id="toc-update-centroids-based-on-new-clusters" class="nav-link" data-scroll-target="#update-centroids-based-on-new-clusters"><span class="toc-section-number">3.2.4</span>  Update centroids based on new clusters</a></li>
  <li><a href="#iterate-for-a-maximum-of-max_iter-times" id="toc-iterate-for-a-maximum-of-max_iter-times" class="nav-link" data-scroll-target="#iterate-for-a-maximum-of-max_iter-times"><span class="toc-section-number">3.2.5</span>  Iterate for a maximum of max_iter times</a></li>
  <li><a href="#packaging-all-up" id="toc-packaging-all-up" class="nav-link" data-scroll-target="#packaging-all-up"><span class="toc-section-number">3.2.6</span>  Packaging all up</a></li>
  </ul></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion"><span class="toc-section-number">3.3</span>  Conclusion</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title d-none d-lg-block"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Broadcasting</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="what-is-broadcasting" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="what-is-broadcasting"><span class="header-section-number">3.1</span> What is Broadcasting?</h2>
<p>In PyTorch, broadcasting refers to the automatic expansion of a tensor’s dimensions to match the dimensions of another tensor during an operation. This allows for element-wise operations between tensors of different shapes, as long as certain rules are followed.</p>
<p>For example, consider the following operation:</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:24.247537Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:23.903099Z&quot;}" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> torch</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.tensor([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>])</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.tensor([<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>])</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+</span> b</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="1">
<pre><code>tensor([5, 7, 9])</code></pre>
</div>
</div>
<p>Here, <code>a</code> and <code>b</code> are both 1-dimensional tensors with shape <code>(3,)</code>. When performing the addition operation, PyTorch will “broadcast” a to have the same shape as b, resulting in a tensor c with shape <code>(3,)</code> and values <code>[5, 7, 9]</code>.</p>
<p>Broadcasting can also occur when one tensor has fewer dimensions than the other. For example:</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:24.251525Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:24.249044Z&quot;}" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> torch.tensor([[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>],</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>                  [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> torch.tensor([<span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> a <span class="op">+</span> b</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Here, <code>a</code> has shape <code>(2, 3)</code> and <code>b</code> has shape <code>(3,)</code>. To perform the addition, PyTorch will broadcast b to have shape <code>(1, 3)</code>, resulting in a tensor c with shape <code>(2, 3)</code> and values.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:24.271012Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:24.252683Z&quot;}" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>c</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="3">
<pre><code>tensor([[ 8, 10, 12],
        [11, 13, 15]])</code></pre>
</div>
</div>
<p>Broadcasting is a powerful feature in PyTorch that allows for efficient operations between tensors of different shapes, and is an important concept to understand when working with deep learning models.</p>
</section>
<section id="exercise-k-means-using-broadcasting-principle" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="exercise-k-means-using-broadcasting-principle"><span class="header-section-number">3.2</span> Exercise: K Means using Broadcasting principle</h2>
<p>In this section we will be using broadcasting principles to showcase the power of broadcasting and implement our own version of K-means clustering which can run on PyTorch. K-Means is a clustering algorithm that is used to group a set of data points into a specified number of clusters. Here is the general pseudocode for the K-Means algorithm:</p>
<ul>
<li>Initialize the number of clusters, <code>k</code>, and the maximum number of iterations, <code>max_iter</code>.</li>
<li>Randomly select <code>k</code> data points as the initial centroids for the clusters.</li>
<li>Iterate for a maximum of <code>max_iter</code> times:
<ul>
<li>Assign each data point to the cluster with the nearest centroid.</li>
<li>Calculate the new centroid for each cluster by taking the mean of all data points in the cluster.</li>
</ul></li>
<li>Return the final clusters and their centroids.</li>
</ul>
<section id="create-some-random-data" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="create-some-random-data"><span class="header-section-number">3.2.1</span> Create some random data</h3>
<p>Let’s try to create some random data using scikit-learn <code>make_blobs</code> function.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:22:42.952420Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:22:42.866929Z&quot;}" data-execution_count="58">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> sklearn.datasets <span class="im">import</span> make_blobs</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>n_samples <span class="op">=</span> <span class="dv">1500</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> make_blobs(n_samples<span class="op">=</span>n_samples, centers <span class="op">=</span> <span class="dv">3</span>, random_state<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">## Normalize</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> (X <span class="op">-</span> X.mean(axis<span class="op">=</span><span class="dv">0</span>))<span class="op">/</span>X.std(axis<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> torch.from_numpy(X)</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> plot_cluster(data, y, points<span class="op">=</span>[]):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    fig, ax <span class="op">=</span> plt.subplots()</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    ax.scatter(data[:,<span class="dv">0</span>], data[:,<span class="dv">1</span>], c<span class="op">=</span>y, cmap<span class="op">=</span><span class="st">'plasma'</span>)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, point <span class="kw">in</span> <span class="bu">enumerate</span>(points):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        ax.plot(<span class="op">*</span>point, markersize<span class="op">=</span><span class="dv">10</span>, marker<span class="op">=</span><span class="st">"x"</span>, color<span class="op">=</span><span class="st">'r'</span>, mew<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        ax.plot(<span class="op">*</span>point, markersize<span class="op">=</span><span class="dv">5</span>, marker<span class="op">=</span><span class="st">"x"</span>, color<span class="op">=</span><span class="st">'b'</span>, mew<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-5-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 1. Visualizing randomly created clusters.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>As we can see above, we have created 1500 samples with three clusters.</p>
</section>
<section id="randomly-initialize-the-centroids" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="randomly-initialize-the-centroids"><span class="header-section-number">3.2.2</span> Randomly initialize the centroids</h3>
<p>For this exercise, we will use a random initialization for the centroids, although there are more sophisticated techniques such as the “kmeans++” method that can be used to improve the convergence of the algorithm. For the sake of simplicity, we will stick with a random initialization.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.057293Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.053195Z&quot;}" data-execution_count="5">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">2</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>centroids <span class="op">=</span> torch.randn((<span class="dv">3</span>,X.shape[<span class="dv">1</span>]))</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Shape: </span><span class="sc">{</span>centroids<span class="sc">.</span>shape<span class="sc">}</span><span class="ss"> </span><span class="ch">\n</span><span class="ss"> </span><span class="sc">{</span>centroids<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Shape: torch.Size([3, 2]) 
 tensor([[ 0.3923, -0.2236],
        [-0.3195, -1.2050],
        [ 1.0445, -0.6332]])</code></pre>
</div>
</div>
<p>Let’s visualize the randomly initialized centroids.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.210066Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.058318Z&quot;}" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, y, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-7-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 2. Visualizing randomly created centroid and cluster.</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>As we can see in the visualization above, the centroids are random.</p>
</section>
<section id="assign-cluster-to-the-nearest-centroid" class="level3" data-number="3.2.3">
<h3 data-number="3.2.3" class="anchored" data-anchor-id="assign-cluster-to-the-nearest-centroid"><span class="header-section-number">3.2.3</span> Assign cluster to the nearest centroid</h3>
<p>We have 1500 samples and three randomly initialized centroids. Now to compute distance between these centroids and samples we can make use of broadcasting which is vectorized and significantly improve our compute times as we don’t need to loop each sample and centroid to calculate distance.</p>
<p>To do broadcasting, we need to make sure that the two tensors are compatible for broadcasting, to achieve this we will add a additional dimension using <code>unsqueeze</code> method.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.214570Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.211599Z&quot;}" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Before unsqueeze: </span><span class="ch">\n</span><span class="ss"> Data shape: </span><span class="sc">{</span>X<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Centroid shape: </span><span class="sc">{</span>centroids<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">After unsqueeae: </span><span class="ch">\n</span><span class="ss"> Data shape: </span><span class="sc">{</span>X<span class="sc">.</span>unsqueeze(<span class="dv">1</span>)<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">, Centroid shape: </span><span class="sc">{</span>centroids<span class="sc">.</span>unsqueeze(<span class="dv">0</span>)<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Before unsqueeze: 
 Data shape: torch.Size([1500, 2]), Centroid shape: torch.Size([3, 2])

After unsqueeae: 
 Data shape: torch.Size([1500, 1, 2]), Centroid shape: torch.Size([1, 3, 2])</code></pre>
</div>
</div>
<p>We can now compute the Euclidean distance between all 1500 samples and the three centroids in a vectorized format. To do this, we will subtract each centroid from the samples, square the differences, and sum them.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.225153Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.216060Z&quot;}" data-execution_count="8">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>square_dist <span class="op">=</span> (X.unsqueeze(<span class="dv">1</span>) <span class="op">-</span> centroids.unsqueeze(<span class="dv">0</span>)).square().<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Distance of 1500 samples with three centroids : </span><span class="sc">{</span>square_dist<span class="sc">.</span>shape<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Distance of 1500 samples with three centroids : torch.Size([1500, 3])</code></pre>
</div>
</div>
<p>For assigning sample to the nearest cluster we can use the <code>argmin</code> function to find the cluster with smallest distance for each sample.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.235416Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.226354Z&quot;}" data-execution_count="9">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(square_dist.argmin(<span class="op">-</span><span class="dv">1</span>)).value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0    974
1    515
2     11
dtype: int64</code></pre>
</div>
</div>
<p>We can see that 974 samples are close to centroid 0 and 515 samples are near to centroid 1 and 11 samples are close to sample 2. Now let’s pack all of the above in a simple function.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.244743Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.238197Z&quot;}" data-execution_count="10">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nearest_centroid(data, points):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Find nearest centroid for each sample </span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data.unsqueeze(<span class="dv">1</span>) <span class="op">-</span> points.unsqueeze(<span class="dv">0</span>)).square().<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>).argmin(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Check if it works as before</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>nc <span class="op">=</span> nearest_centroid(X,centroids)</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(pd.DataFrame(nc).value_counts())</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>0    974
1    515
2     11
dtype: int64</code></pre>
</div>
</div>
<p>Let’s visualize the cluster assignment.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.614841Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.246045Z&quot;}" data-execution_count="11">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, nc, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-12-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 3. Visualizing newly created cluster based on centroids</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
<section id="update-centroids-based-on-new-clusters" class="level3" data-number="3.2.4">
<h3 data-number="3.2.4" class="anchored" data-anchor-id="update-centroids-based-on-new-clusters"><span class="header-section-number">3.2.4</span> Update centroids based on new clusters</h3>
<p>To obtain the new centroid coordinates, we need to compute the mean of all the samples that are assigned to the cluster and update the centroids accordingly.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.619192Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.616287Z&quot;}" data-execution_count="12">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_centroids(data, nc):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>  torch.cat([data[nc <span class="op">==</span> val,:].mean(axis<span class="op">=</span><span class="dv">0</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="cf">for</span> val <span class="kw">in</span> torch.unique(nc)], <span class="dv">0</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>new_centroids <span class="op">=</span> update_centroids(X, nc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Lets visualize the new updated centroids.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.709250Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.620221Z&quot;}" data-execution_count="13">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, nc, new_centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-14-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 4. Visualizing newly created centroids based on nearest cluster assignment</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>We can see updated centroids moved to the middle of the cluster.</p>
</section>
<section id="iterate-for-a-maximum-of-max_iter-times" class="level3" data-number="3.2.5">
<h3 data-number="3.2.5" class="anchored" data-anchor-id="iterate-for-a-maximum-of-max_iter-times"><span class="header-section-number">3.2.5</span> Iterate for a maximum of max_iter times</h3>
<p>Let’s set max_iter to 20 and run the cluster assignment and updating centroid for max_iter times.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.718203Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.710580Z&quot;}" data-execution_count="14">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>max_iter <span class="op">=</span> <span class="dv">20</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>torch.manual_seed(<span class="dv">2</span>)</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>centroids <span class="op">=</span> torch.randn((<span class="dv">3</span>,X.shape[<span class="dv">1</span>]))</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(max_iter):</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    nc <span class="op">=</span> nearest_centroid(X,centroids)</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a>    centroids <span class="op">=</span> update_centroids(X, nc)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s visualize the centroids after running it <code>max_iter</code> times.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:09:25.803461Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:09:25.719492Z&quot;}" data-execution_count="15">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, y, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 5. Visualizing final cluster centers with original labels</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>We can see now that the centroids have converged to the desired cluster center.</p>
</section>
<section id="packaging-all-up" class="level3" data-number="3.2.6">
<h3 data-number="3.2.6" class="anchored" data-anchor-id="packaging-all-up"><span class="header-section-number">3.2.6</span> Packaging all up</h3>
<p>Let’s package all the above functions to do K means.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:15:24.199722Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:15:24.196129Z&quot;}" data-execution_count="46">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nearest_centroid(data, points):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (data.unsqueeze(<span class="dv">1</span>) <span class="op">-</span> points.unsqueeze(<span class="dv">0</span>)).square().<span class="bu">sum</span>(axis<span class="op">=-</span><span class="dv">1</span>).argmin(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> update_centroids(data, nc):</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>  torch.cat([data[nc <span class="op">==</span> val,:].mean(axis<span class="op">=</span><span class="dv">0</span>, keepdim<span class="op">=</span><span class="va">True</span>) <span class="cf">for</span> val <span class="kw">in</span> torch.unique(nc)], <span class="dv">0</span>)</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> k_means(X, k, max_iter<span class="op">=</span><span class="dv">20</span>, device<span class="op">=</span><span class="st">"cpu"</span>):</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Random initialization</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> device <span class="op">==</span> <span class="st">"cpu"</span>: </span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> X.detach().cpu()</span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: </span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> X.to(device)</span>
<span id="cb23-13"><a href="#cb23-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-14"><a href="#cb23-14" aria-hidden="true" tabindex="-1"></a>    centroids <span class="op">=</span> torch.randn((k,X.shape[<span class="dv">1</span>])).to(device)</span>
<span id="cb23-15"><a href="#cb23-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-16"><a href="#cb23-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Updating centroids for max_iter</span></span>
<span id="cb23-17"><a href="#cb23-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="bu">iter</span> <span class="kw">in</span> <span class="bu">range</span>(max_iter): </span>
<span id="cb23-18"><a href="#cb23-18" aria-hidden="true" tabindex="-1"></a>        new_centroids <span class="op">=</span> update_centroids(X, nearest_centroid(X,centroids)).to(centroids.dtype)</span>
<span id="cb23-19"><a href="#cb23-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb23-20"><a href="#cb23-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">## Early stopping</span></span>
<span id="cb23-21"><a href="#cb23-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> torch.equal(centroids,new_centroids): <span class="cf">break</span></span>
<span id="cb23-22"><a href="#cb23-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>: centroids <span class="op">=</span> new_centroids</span>
<span id="cb23-23"><a href="#cb23-23" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb23-24"><a href="#cb23-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> centroids</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s check if the function runs correctly.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:17:34.807556Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:17:34.724114Z&quot;}" data-execution_count="55">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>centroids <span class="op">=</span> k_means(X,<span class="dv">3</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>plot_cluster(X, y, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-18-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 6. Visualizing output cluster centers with original labels</figcaption><p></p>
</figure>
</div>
</div>
</div>
<p>Let’s run the function on GPU.</p>
<div class="cell" data-executetime="{&quot;end_time&quot;:&quot;2022-12-27T04:17:15.016482Z&quot;,&quot;start_time&quot;:&quot;2022-12-27T04:17:14.902301Z&quot;}" data-execution_count="54">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>centroids <span class="op">=</span> k_means(X,<span class="dv">3</span>, device<span class="op">=</span><span class="st">"cuda"</span>).detach().cpu()</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>plot_cluster(X.detach().cpu(), y, centroids)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-left">
<figure class="figure">
<p><img src="2_broadcasting_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">Fig 7. Visualizing output cluster centers with original labels</figcaption><p></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="conclusion" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="conclusion"><span class="header-section-number">3.3</span> Conclusion</h2>
<p>Broadcasting is a powerful feature in PyTorch that allows you to perform arithmetic operations on tensors of different shapes, as long as they are “broadcastable.”</p>
<p>As we have seen above, broadcasting allows you to perform operations on tensors of different shapes as if they were the same shape, by repeating or “broadcasting” the values of the smaller tensor along the missing dimensions. This can be a useful way to perform element-wise operations on tensors without having to explicitly pad or resize them.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  let localAlternateSentinel = 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../basics/1_pytorch_tensors.html" class="pagination-link">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Tensors</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../basics/3_autograd.html" class="pagination-link">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">Automatic Differentiation</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">The PyTorch book. Copyright (c) 2022 Aayush Agrawal.</div>   
    <div class="nav-footer-right">This book was built with <a href="https://quarto.org/">Quarto</a></div>
  </div>
</footer>



</body></html>